[{"title":"what often do you go out on weekends?","path":"/post/f1145514.html","content":"Q: what often do you go out on weekends? A:I mostly like to stay at home with my cat on weekends.I often spend time reading interesting books.It allows me to immersemyself in different worlds and gain knowledge.Sometimes,I watch movies. I really enjoy various movies.Moreover,I also use this timeto study and improve my work skills. By learning new things,I can be more competitive at work.This way,I can fully relax and rechargemy energy during the weekends,getting read for the upcoming week.","tags":["english","雅思"],"categories":["english"]},{"title":"An old man's advice","path":"/post/64820e8d.html","content":"I’ve decided to share a little bit about myself and my life, and my hardships and my successes with you. You konow ,this world today is tough. it’s tough for young people. It’s tough for people that for years have had jobs and security,made good money,had been able to take care of their families. And some time ago,as you konw,jobs were shipped overseas to improve the bottom line big companies. And i thought i’d tell you a little bit about myself. I quit school when i was in a 10th grade. My mother and father left me standing on a street corner. It’s always up to me to make it . And i had a job working at a shell filling station.and i went to the owner and i told him my situation , and i was making a dollar an hour,and i asked him if i could work more hours. I tried begining working 90 hours a week .And during that time,as I’ve said before,my home was the back of an old car,and i work my 90h a week .Then i took my baths in a public station restroom ,and i washed my clothes. My private clothes in a sink. and once in a while ,when I was really hungry,i’ll go to the grocery store and snitch an apple,an orange.and that was in the fifties.Things were a lot different than they are now,and i’m convinced that the owner of the grocery store knew what i was doing. because it was about a half a block away from where i worked,and he knew me.I’ve said before that good things and bad things last forever,and that’s true. and i began to learn different things. i knew in my soul that if i had nothing to offer,i was as far as i was going to go. now , unemployment at that time was very high.on the other hand , in the fifties ,you could go to into a corporation and ask for a job and get it.And after i’d work 90h a week for a long time,i went into the service. i was 17 in the service,i taught myself to read and write .the first book i picked up was a book written by Louis Slamore, and 196 pages in it. i’ll never foget it. there was a cowboy story at western and there were war junior that i didn’t know. i didn’t understand .i had no idea what they were.so i got a dictionary from the service library, and as i would read ,if there was a word that i didn’t understand,i would look it up .and would tell you now , i took almost three weeks to read 196 pages,but i read, and i continue to read ,and in several months,i was reading two and three books at a time,and i knew where i was in every single one of them.So that’s what you can do.A person’s mind is incredible .Your mind is incredible.As a yound person,regardless of what’s happening in the world today,you have opportunity .And don’t you believe for one single minute what they say in the media.Because if you aren’t getting ahead,you need to get ahead.position yourselelf to learn. go to the library and learn.you are the backbone of this world.yound people. without you, this world is noting.nothing,you are the backbone of this world.you are the future leaders of the world.you are the ones that see the greed of the people that are running it now.we need you ,we need your mind.we need your hearts. we need your lives.we need your loves. we need you to care.and i know that you do care. oh, i see yound people stepping on a flag and throwing rocks,rioting.that’s frustration .it’s frustration with the establishment,and i understand it .but that’s not you,don’t let that be.you rise above it.you’re better than that. rise above it.anyway,i got kind of off track there.but anyway,as i went on , and i got out of the service,i had begun to write and educate myself.i got a little bit of colleage,and i continued on through my life with that.and you can do any thing,you don’t have to have a doctor or PHD or a masters degree.what you have to have is determination .you have to have an inner will to get things done.you have to have a desire.and i know the desire is there.because as i said before,without your brains,without your ambition,without your drive. You can’t stop. You can’t quit.you can’t say,i’m a failure.","tags":["人生建议","english"],"categories":["english"]},{"title":"elasticSearch 8.9.2 基本操作API","path":"/post/9f15dbec.html","content":"创建索引 手动创建索引 123456789PUT /pai_search&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;age&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &#125; &#125;&#125; Tip: 这里的keyword要注意，如果字段类型为keyword，那么这个字段在查询的时候不会被分词器解析 添加索引字段 1234567891011PUT /pai_search/_mapping&#123; &quot;properties&quot;: &#123; &quot;tag&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;, &quot;score&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125; &#125;&#125; 查看索引 1GET /my-index-000001/_mapping 查看索引指定字段 12## 这里没有复现出来，执行结果为空GET /pai_search/_mapping/field/age 添加数据 新增一条数据 1234567PUT /pai_search/_doc/9&#123; &quot;age&quot;: 90, &quot;name&quot;:&quot;xiaoxiao&quot;, &quot;score&quot;: 10, &quot;tag&quot;:[&quot;篮球&quot;,&quot;学习&quot;,&quot;跑步&quot;]&#125; 批量新增数据 12345678910111213141516171819202122232425262728293031323334POST /pai_search/_bulk&#123; &quot;index&quot;: &#123; &quot;_id&quot;: &quot;6&quot; &#125;&#125;&#123; &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30, &quot;score&quot;: 85, &quot;tag&quot;: [&quot;developer&quot;]&#125;&#123; &quot;index&quot;: &#123; &quot;_id&quot;: &quot;7&quot; &#125;&#125;&#123; &quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 25, &quot;score&quot;: 90, &quot;tag&quot;: [&quot;designer&quot;]&#125;&#123; &quot;index&quot;: &#123; &quot;_id&quot;: &quot;8&quot; &#125;&#125;&#123; &quot;name&quot;: &quot;Charlie&quot;, &quot;age&quot;: 35, &quot;score&quot;: 88, &quot;tag&quot;: [&quot;manager&quot;]&#125; 查询​\t官网api：https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html 查询所有 12345678910111213141516171819202122232425262728293031323334353637GET /pai_search/_search# 索引和文档信息&#123; &quot;took&quot;: 2, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 9, # 查询结果总数 &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 1, &quot;hits&quot;: [ # 查询结果 &#123; &quot;_index&quot;: &quot;pai_search&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;age&quot;: 10, &quot;name&quot;: &quot;xiaoxiao&quot;, &quot;score&quot;: 10, # 每个查询结果都有一个分数，表示结果匹配度，越大匹配度越高 &quot;tag&quot;: [ &quot;篮球&quot;, &quot;学习&quot;, &quot;跑步&quot; ] &#125; &#125; ] &#125;&#125; 根据id查询 123456789101112131415161718192021GET /pai_search/_doc/1# 索引和文档信息&#123; &quot;_index&quot;: &quot;pai_search&quot;, # 索引 &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, # 修改的次数 &quot;_seq_no&quot;: 0, &quot;_primary_term&quot;: 3, &quot;found&quot;: true, &quot;_source&quot;: &#123; &quot;age&quot;: 10, &quot;name&quot;: &quot;xiaoxiao&quot;, &quot;score&quot;: 10, &quot;tag&quot;: [ &quot;篮球&quot;, &quot;学习&quot;, &quot;跑步&quot; ] &#125;&#125; 条件匹配查询、排序、过滤字段、分页 12345678910111213141516GET /pai_search/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123;&quot;name&quot;: &quot;xiaoxiao&quot;&#125;, &#125;, &quot;_source&quot;: [&quot;age&quot;,&quot;name&quot;,&quot;tag&quot;], &quot;sort&quot;: [ &#123; &quot;age&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125; &#125; ], &quot;from&quot;: 0, &quot;size&quot;: 10,&#125; 上面的query是用于匹配查询结果，_source 用于保留显示指定的字段，sort 用于指定字段排序,from 指从0开始，保留size大小的个数 多个条件must查询（and）、should查询（or）、must_not查询（not）、filter根据字段过滤 123456789101112131415GET /pai_search/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123;&quot;match&quot;:&#123;&quot;name&quot;:&quot;xiaoxiao1&quot;&#125;,&#125; ], &quot;filter&quot;: &#123; &quot;range&quot;:&#123; &quot;age&quot; : &#123;&quot;gt&quot;: 20,&quot;lt&quot;: 28,&#125; &#125; &#125;, &#125;, &#125;,&#125; 上面是查询name = &quot;xiaoxiao1&quot; and age &gt; 20 and age &lt; 28 的数据； 这里的must可以替换为should、must_not等 数组字段匹配查询 12345678910GET /pai_search/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123;&quot;match&quot;:&#123;&quot;tag&quot;:&quot;篮球3 跑步&quot;&#125;,&#125; ], &#125;, &#125;,&#125; 3 25 xiaoxiao1 30 [“篮球3”,”学习”,”跑步”] 1 10 xiaoxiao 10 [“篮球”,”学习”,”跑步”] 9 90 xiaoxiao 10 [“篮球”,”学习”,”跑步”] 2 20 xiaoxiao1 20 [“篮球2”,”学习”,”跑步”] 4 25 xiaoxiao1 40 [“篮球4”,”学习”,”跑步”] 5 30 xiaoxiao1 50 [“篮球5”,”学习”,”跑步”] 这里的匹配结果会出现很多权重很低的数据，因为不是精确匹配所以包含篮球3、跑步这两个关键词的都出现了 字段精确匹配查询 term : 直接精确查询 match： 会使用分词器解析，再查询 1234567891011GET /pai_search/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;should&quot;: [ &#123; &quot;term&quot;: &#123;&quot;score&quot; : &quot;20&quot;&#125; &#125;, &#123; &quot;term&quot;: &#123;&quot;score&quot; : &quot;30&quot;&#125; &#125;, ] &#125; &#125;,&#125; 上面这个查询可以通过term精确查询分值为20或30的数据; 高亮查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960GET /pai_search/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match&quot;:&#123; &quot;name&quot;:&quot;xiaoxiao1&quot; &#125;, &#125; ], &#125;, &#125;, &quot;highlight&quot;:&#123; &quot;fields&quot;: &#123; &quot;name&quot;: &#123; &#125; &#125; &#125;&#125;## 查询结果&#123; &quot;took&quot;: 26, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 4, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 0.7985077, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;pai_search&quot;, &quot;_id&quot;: &quot;2&quot;, &quot;_score&quot;: 0.7985077, &quot;_source&quot;: &#123; &quot;age&quot;: 20, &quot;name&quot;: &quot;xiaoxiao1&quot;, &quot;score&quot;: 20, &quot;tag&quot;: [ &quot;篮球2&quot;, &quot;学习&quot;, &quot;跑步&quot; ] &#125;, &quot;highlight&quot;: &#123; &quot;name&quot;: [ &quot;&lt;em&gt;xiaoxiao1&lt;/em&gt;&quot; ## 这里是高亮的结果 ] &#125; &#125; ] &#125;&#125; 上面这个查询语句时查询name为xiaoxiao1的数据，并把查询中的name进行高亮","tags":["elasticSearch"],"categories":["elasticSearch"]},{"title":"JVM面试题","path":"/post/4d902e4f.html","content":"类加载器什么时候触发加载？ 使用new关键字实例化对象时； 访问类的静态方法； 反射 class.forName(); 初始化一个类时，发现其父类没有初始化； 虚拟机启动时，定义了main方法，那个类先初始化； Java 文件加载到内存的过程： 1. 加载 就是把编译后的class文件，通过类加载器加载（二进制流的方式）到方法区称为DNA元数据模板 2. 链接： 1. 验证：魔数的校验 2. 准备：初始化类变量（静态变量）为0值；final修饰的是在编译时初始化，这个阶段显示赋值；实例变量不在这时初始化； 3. 解析：将常量池中的符号引用转化为直接引用；javap -v class 可以看到编译后的方法使用都是符号引用 3. 初始化： 给类变量显示赋值 执行类构造器方法（clinit）的过程；如果有父类会先执行父类的clinit()方法； 虚拟机保证一个类的clinit方法被调用时被加锁，只能调用一次； 双亲委派是什么 双亲委派： 系统类加载器-》 扩展类加载器-》 引导类加载器；层层向上委派；反向委派： rt.jar 是由引导类加载的，但是具体实现类是第三方的，是由系统类加载器加载的； 类加载器类型： Bootstrap classload(引导类加载器)： 加载包名为java、javax、sun开头的 扩展类加载器：主要加载ext扩展目录下的类； application classload （系统类加载器）： 负责加载classpath下的类库，一般的程序都是此加载器加载； Custom classLoad（自定义类加载器） 堆是存储的单位，栈是运行时的单位；堆： 存储字符串常量池 编译器输入指令流分为： 基于栈的指令集架构，基于寄存器的指令集架构； 栈式架构： 1. 实现简单，适用于资源受限的系统 2. 使用零地址指令； 3. 不依赖操作系统，可移植性好，支持跨平台； 寄存器架构： 依赖硬件，可移植性差； 性能优秀，执行更少的指令 java的指令都是基于栈进行设计的；虚拟机栈： 存在oom（内存溢出），不存在GC， 1. 局部变量表： 基本单位是slot 2. 操作数栈：（tip: 局部变量使用时，必须显示赋值；） 1. 操作数栈是jvm执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建，这时操作数栈是空的； 2. 操作数栈都会拥有一个明确的栈深度用于存储数值，最大的深度在编译器就定义好了；javap可看到； 3. 动态链接： 这里只是指方法层面的把符号引用转化为直接引用； 4. 方法返回地址 5. 附加信息 方法区（元空间）： 包含： 类型信息（接口、枚举等信息）、 域信息（public、private、projected…）、 方法信息(方法名称、方法返回值…)、 运行时常量池（就是javap 中看到的常量池，在运行时加载到内存中，就叫运行时常量池） 内存泄漏:是由程序导致分配的内存没有被正确回收导致；通常需要排查代码； 内存溢出：通常是可分配的内存超过了总的内存大小,内存泄漏最终也可能导致内存溢出；通过设置jvm堆内存大小xms、xmx **Minor GC(年轻代)**： 会触发STW，暂停其他用户的线程，等待垃圾收集结束，用户线程才恢复运行； Major GC（老年代）: 会触发STW，执行major GC前会先执行minor GC; Full GC ： 触发条件： system.gc(); 老年代空间不足； 方法区（元空间）空间不足； young gc 后进入老年代的大小大于老年代可用容量大小； s1区或s0区满后，进入老年代的大小大于老年代可用容量大小； 堆：TLAB: 堆区是线程共享的区域，任何线程都可以访问堆区；为了避免多个线程 创建对象的5个步骤： 判断对象是否加载、链接、初始化、 为对象分配内存空间： 内存规整； 指针碰撞 内存不规整： 空闲列表分配； 处理并发安全问题 初始化分配到的空间； 设置对象的对象头信息； 执行init方法进行初始化； finalize: 可触及 可复活： 所有的对象引用都被释放，但是对象有可能在finalize()中复活； 不可触及： 强引用（可触及）： 不回收软引用（可触及）： 内存不足即回收弱引用：一旦失去最后一个强引用，有GC时就回收虚引用：用于跟踪对象的回收，因为创建虚引用的时候会传一个引用队列； 可达性分析算法中GC Roots的对象： 虚拟机栈（栈帧中的本地变量表）中引用的对象 本地方法栈中的引用对象 方法区中的类静态成员变量中的对象 方法区中的常量引用对象 垃圾回收算法： 标记阶段： 引用计数算法 可达性分析算法 清除阶段： 复制算法（建立在存活对象少，垃圾对象多的情况： 适用于新生代； ） 标记-清除算法（老年代适用） 标记-压缩算法 （老年代适用） 扩展： 分代收集算法（分代思想）：由于上面3种算法，各有优劣，但是没有一个完美的解决方案，所以提出分代（例如：新生代、老年代）分别使用不同的垃圾回收算法，提高回收效率；新生代可以用复制算法，速度快，垃圾多；老年代可以用标记-清除、标记-压缩算法，垃圾少，不需要特别快的速度； 增量收集算法：由于STW时间太长，可以让应用线程和垃圾收集线程交替执行，分阶段的收集垃圾；总的来说，增量收集算法是对现成冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作； 分区算法：这个算法与上面的增量收集算法基本一样，主要也是降低STW的时间，主要应用于G1垃圾回收器；将一个大的内存空间分隔成一个一个小的内存空间，在规定时间内，进行最大的回收垃圾 GC算法比较： 速度： 复制算法最快、标记压缩最慢 空间开销： 复制算法需要的空间最大，一般是需要复活对象的2倍；标记-压缩空间开销最小； 移动对象：标记-清除算法不需要移动对象； 垃圾收集器：serial GC(新生代)+ serial old （老年代）: 串行 最小化使用内存和并行开销Parallel GC（新生代）+ parlllel old 最大化应用程序的吞吐量parNew（新生代）+CMS(老年代)： 最小的中断和停顿时间 CMS 初始标记 、并发标记、重新标记、并发清除； 默认：使用标记-清除算法初始标记： stw时间很短， GCroot能直接关联的对象并发标记： 从GC root直接关联对象开始遍历整个对象图的过程；耗时长； 与用户线程并发执行重新标记： stw时间很短 重新标记一下并发清除： 与用户线程并发执行；此阶段清除标记阶段判断已死亡的对象，释放内存；-XX:+UserConcMarkSweepGC 时，老年代使用CMS，新生代默认是ParNew cms的优缺点； 并发收集； 低延迟； 缺点： 会产生内存碎片，无法分配大对象； 与用户线程并发执行阶段，会占用部分线程，总吞吐量降低； 无法清除浮动垃圾；","tags":["JVM","面试"],"categories":["JVM"]},{"title":"redis面试题","path":"/post/4370f109.html","content":"为什么redis使用单线程反而更快？ 内存操作： redis是一个内存数据，内存的读写数据天生就是快； 单线程模型： 单线程模型避免了多线程上下文切花带来的开销 采用事件驱动的IO多路复用模型： 事件驱动的IO多路复用模型结合了非阻塞IO和事件驱动的优点，非常适合处理大量并发连接的场景。通过事件循环和事件处理器的机制，能高效的管理多个IO流，同时避免了线程上下文切换的开销，是现代高性能服务器架构的核心技术之一。 命令的原子性： 大部分命令都是原子性，命令的原子性和单线程模型可以确保在任何时刻只有一个命令在执行，消除了对复杂的数据结构的保护和锁的需求，提高整体效率。 数据结构优化： redis使用了高效的数据结构，如跳跃表、压缩列表、哈希表等，这些数据结构提供了快速的查找和操作速度，有助于维持高性能。 C语言编写更接近于底层语言 TIP:主要瓶颈是网络IO和CPU的计算能力，而不是线程间的并行处理。在多核CPU环境下，Redis从v4.0开始引入了多线程来处理后台任务（如AOF重写），并在v6.0中增加了对多线程的网络处理支持。 redis有哪些常用的数据类型？ redis常用的数据类型有5种：String、List、Hash、Set、Sorted Set；如下图所示 String: 底层结构叫SDS（Simple Dynamic String），是一个带长度信息的字节数组；规定字符串长度不得超过512M；当字符串长度小于或等于44时，使用embstr形式存储，大于44时，使用raw形式存储； embstr形式存储：SDS的存储一般是连续的（意思就是redisObject对象头和SDS对象连续存在一起，malloc时一起分配）。 raw形式存储：SDS不是连续存储的（需要两次malloc分配） Hash: 存对象 使用字典（dict）。字典由一个哈希表和多个压缩列表或字典组成，当元素较少时使用压缩列表（ziplist），节省内存；当元素较多时转换成普通的哈希表。7.0+版本较少时使用的紧凑列表listpack； List: 可以做队列 使用压缩列表（ziplist）或 QuickList（快速列表）。对于小列表，使用压缩列表来节省空间；对于大列表，则使用双向链表。7.0+版本压缩列表（ziplist）替换为紧凑列表（listpack）； ZSet: 存储的value是不能重复的，分值score是可以重复的； 使用字典（dict）和跳跃表（skiplist）。字典用来存储Value和分数Score的映射，跳跃表用来按照分数排序；当数据比较少的时候用ziplist存储，否则用跳跃表。 Set: 有去重的功能 使用整数集合（intset）或字典（dict）。当集合中的所有元素都可以被表示为整数时，使用整数集合来节省内存；当集合中有非整数元素时，转换成字典结构 Stream 使用字典和快速链表（quicklist）。每个流元素存储在快速链表中，整个流则是一个字典，其中键是流ID，值是快速链表 有序集合（Zset）底层是如何实现的？ 有序集合是由hash 字典+ （ziplist（压缩列表）或 skiplist（跳跃表））组成。hash字典用来存储Value和分数Score的映射； 压缩列表ziplist本质上就是一个字节数组，压缩列表是一块连续的内存空间，没有任何冗余间隙； 跳跃表skiplist是一种有序的双向连链表结构； tip: 只有完全满足以下两个条件才能使用ziplist，反之则使用skiplist 有序集合的元素个数小于128个 有序集合的所有元素成员的长度都必须小于64字节； redis如何保证数据不丢失？ 保存数据不丢失主要在两个方面：1. 持久化；2. 集群部署 持久化： RDB持久化：快照方式持久化，将某一个时刻的内存数据，以二进制的方式写入磁盘； 优点： 速度快： 空间占用小 恢复速度快 可靠性高 缺点： 实时性差 数据可能会丢失 AOF持久化：文件追加持久化，记录所有非查询操作命令，并以文本的形式追加； 优点： 数据不容易丢失 实时性好 数据可读性强 缺点： 写入性能低 占用磁盘空间大 AOF文件可能会出现损坏； 混合持久化：RDB+AOF混合方式的持久化，在写入的时候，先把当前的数据以RDB的形式写入文件的开头，再将后序的操作命令以AOF的格式存入文件； TIP: 总结下RDB和AOF的优缺点主要在5个方面： 写入方式：RDB是通过快照的形式，以二进制的方式写入磁盘中，AOF是通过追加命令的形式，以命令的方式写入在AOF文件中； 数据恢复：RBD是某一时间点的数据，可以直接加载到内存中快速恢复；AOF则需要逐条执行命令恢复，需要时间长； 数据完整性：RDB文件保存的是某一时间点的数据快照，宕机后，可能会丢失一部分数据；AOF是记录redis所有的命令，因此AOF丢失的命令会少很多； 文件大小：RDB文件以二进制形式存储，文件小；AOF文件存储的是命令内容，则文件大； 性能影响：AOF文件追加写的方式不会阻塞；RDB文件在快照时可能会阻塞redis服务； 集群部署： 主从同步 哨兵模式 redis 集群 redis的内存淘汰策略有哪些？什么时候触发呢？ redis在3种情况下会触发内存的淘汰策略： 当写操作内存超过限制：我们可以通过config get maxmemory查询redis能使用的最大内存值，当使用超过这个maxmemory时就会触发内存淘汰策略； 启用AOF重写操作：如果使用AOF持久化方式并开启AOF重写功能时，那么在执行AOF重写过程中会触发内存淘汰策略。AOF重写是将AOF原来的文件重写为一份更为紧凑的格式，减少内存的占用； 通过命令主动释放内存：通过主动执行MEMORY PURGE命令释放内存； 淘汰策略： noeviction：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略； allkeys-lru：淘汰整个键值中最久未使用的键值； allkeys-random：随机淘汰任意键值； allkeys-lfu：淘汰整个键值中最少使用的键值。 volatile-lru：淘汰所有设置了过期时间的键值中最久未使用的键值； volatile-lfu：淘汰所有设置了过期时间的键值中，最少使用的键值 volatile-random：随机淘汰设置了过期时间的任意键值； volatile-ttl：优先淘汰更早过期的键值; TIP: LRU是在一段时间范围内最久未使用，基于时间的维度；LFU是在一段时间范围内使用次数最少的，基于访问频率的维度； 缓存雪崩、缓存击穿、缓存穿透是什么？怎么解决？ 缓存雪崩：指缓存中存在大量的键同时过期或失效，导致大量请求直接访问到数据库或服务； 原因： 大量缓存键同时过期 缓存服务器故障 解决方案： 设置随机过期时间 实现缓存预热：在服务启动或者缓存失效前，提前加载热点数据； 使用分布式缓存集群：减少单节点压力，提高系统的可用性和抗压性； 服务熔断或降级 增加监控和告警机制 缓存击穿：某个热点数据过期或失效，导致大量数据同时访问数据库或服务； 原因： 热点数据失效 并发访问热点数据 解决方案： 设置热点数据永不过期或过期时间比较长 加互斥锁或分布式锁；加分布式锁，只有一个线程能进入； 限制并发访问；限制热点数据并发访问的量； 缓存穿透：恶意请求查询不存在缓存和数据库中的数据，导致这些请求直接访问数据库； 原因： 恶意请求 高并发请求（正常请求）：当有大量的并发请求通过查询不存的数据时，可能会导致缓存无法命中，从而触发缓存穿透； 解决方案： 使用布隆过滤器： 缓存空值处理：可以将查询出来的空值做一个短期的缓存，防止相同的请求打到数据库； 异步缓存加载：缓存未命中时，可以异步加载数据到缓存中，通过使用分布式锁来保证只有一个线程去加载数据，避免重复加载； 限制恶意请求：通过访问频率控制、验证码等手段","tags":["面试","redis"],"categories":["redis"]},{"title":"mysql面试题","path":"/post/e0f8559b.html","content":"mysql中有哪些锁？ 共享锁（Shared Locks 或 S 锁）： 共享锁允许多个事务同时读取同一数据，但不允许任何事务在同一数据上进行写操作； 排他锁（Exclusive Locks 或 X 锁）： 排他锁阻止其他事务读取或修改同一数据，当一个事务需要更新或删除数据时，它会获取排他锁； 意向共享锁（Intent Shared Locks 或 IS 锁）&amp;&amp; 意向排他锁（Intent Exclusive Locks 或 IX 锁）： 加锁的时候可能锁某一行或几行的数据，也可能锁整个表，但共享锁只能和共享锁兼容，排他锁和两者（共享锁、排他锁）都不兼容。举一个极端的例子，如果共享锁锁表（全表扫描查询），难道需要一行行遍历看数据是否被排他锁锁过吗？同理，排他锁锁表时，就需要一行行遍历是否存在数据被共享锁或者排他锁占用。 所以提出了IS锁和IX锁，减少行级锁和表级锁的冲突，以下是共享锁、排他锁、意向共享锁、意向排他锁的兼容关系 X（排他锁） IX（意向排他锁） S（共享锁） IS（意向共享锁） X ❌ ❌ ❌ ❌ IX ❌ ✅ ❌ ✅ S ❌ ❌ ✅ ✅ IS ❌ ✅ ✅ ✅ Tip： IX和IX能兼容是因为多个IX锁时获取不同行数据的行锁，可以同时存在；同理，IX和IS兼容也是一样； 记录锁（Record Locks）： 锁定特定记录或行，锁定的行数是固定的； 间隙锁（Gap Locks）：左开右开 间隙锁的目的是在RR级别下，防止幻读，幻读的产生是当前事务多次的查询结果的数量不一致；间隙锁的目的就是保证当前范围内的数据不会被更改，所以它会锁住某些区间的数据； 临键锁（Next-Key Locks）：左开右闭 等于记录锁+间隙锁，所以我们只需要知道两个锁的定义就行，Mysql在隔离级别为RR时，默认是Next-key锁； 表级锁（Table Locks）： 行级锁（Row Locks）： 这种锁是最细粒度的锁，只锁定被事务访问的具体行。Innodb存储引擎支持行级锁； 页级锁（Page Locks）： 页级锁锁定的是数据库页，这是介于行级锁和表级锁之间的中间级别。某些存储引擎可能会使用页级锁，但InnoDB主要使用行级锁； 索引底层是如何实现的？ Mysql中默认的存储引擎是Innodb，其索引是使用B+树实现的。B+树是一种多路搜索树，它的叶子节点存储了所有的数据行信息，叶子节点之间使用指针连接，方便范围查询和排序等操作，非叶子节点存储的是索引字段的值（主键索引存存的是id）； 为什么要选择B+树： 查询效率： 内存：B+树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比B树（即存数据又存索引）大大节省了内存空间 IO操作：B+树的层级比B树更少，查询所需的IO操作更少； 插入和删除效率： B+树相比于B树新增和删除节点不用复杂的结构变化； 查询范围： B+树的叶子节点有指针连接方便进行范围查找 聚簇索引和非聚簇索引的区别？ 聚簇索引和非聚簇索引的区别主要在数据的存储和查询： 数据存储： 聚簇索引（也即主键索引）的叶子节点存储的是主键对应的一行完整的数据，非聚簇索引（非主键索引）的叶子节点存储的是主键值，然后回表查询主键信息； 范围查询： 聚簇索引中的数据行与索引行一一对应的，因此聚簇索引通常比非聚簇索引更适合范围查询，而非聚簇索引需进行而进行二次查询：首先查找索引，然后查找数据行，这会导致性能问题，特别是大型表上进行范围查询； 什么情况会导致索引失效？ 不符合最左匹配原则 使用列运算 使用函数 使用类型转换 is not null 错误的模糊查询 mysql事务有哪些特性？ 原子性（A）:事务中执行的操作要么全部成功，要么全部失败； 一致性（C）：事务执行前后事务的一致性没有被破坏，只能从一个一致性状态到另一个一致性状态；这里常说A转账B的问题，不管转账成功失败，A+B的总金额应该是不变的 隔离性（I）：事务之间相互隔离，每个事务对其他事务的操作都是透明的； 持久性（D）：事务完成后，对数据库的修改将永久保存在数据库中，即使系统故障也不会丢失； 如何保证事务四大特性（ACID）? 原子性：原子性是通过undo log（回滚日志）保证，InnoDB使用日志（undo log）来记录事务从开始到结束的所有操作，当事务提交失败时，通过undo log日志来回滚执行的数据，来确保事务的原子性； 持久性：持久性是通过redo log（重做日志）保证，在事务提交之前，innodb会将事务的修改操作先写入redo log 中，然后再将数据写入磁盘。即使在系统崩溃或断电的情况下，innodb可以通过重放事务日志来恢复数据，来确保事务的持久性。 隔离性：MVCC（多版本并发控制）和锁机制来保证； 一致性：一致性是通过各种约束，如主键，唯一性约束等，同时加上事务的持久性、原子性、隔离性同时来保证一致性； 不可重复读和幻读的区别？ 不可重复读是指多次查询同一行数据，每次查询出来的结果都不同； 幻读是指范围查询时，会出现数据的个数总是在变化； 解决方案： 不可重复读通常通过提高隔离级别为RR或者手动使用行锁； 幻读：通过提高隔离级别为串行或者手动SELECT ... FOR UPDATE或SELECT ... LOCK IN SHARE MODE时，InnoDB会在行级加锁的同时，也可能加间隙锁 MVCC是什么？能解决幻读吗？ MVCC是一种并发控制机制，主要用来解决幻读的问题。MVCC的核心思想是将每个事务的读操作与写操作解耦，通过保存数据的历史版本来控制并发，每个事务都会创建一个读视图（read-view），用于确定在事务开始时可见的数据版本，旧版本的事务会保存在undo log中（mysql有undo log缓存） 读操作：当一个事物执行SELECT语句时，会根据读视图的版本号与数据行的版本号就行比对，只读取在事务之前已经提交的数据行。这样，即使其他事务正在并发的插入或者删除数据，事务仍然可以读取到一致的数据。 写操作：当一个事务执行INSERT、UPDATE或DELETE语句时，会生成新的数据版本，并将旧版本的数据保存在undo log中.这样，其他事务在读取数据时仍然可以访问到旧版本的数据，从而避免幻读的问题； RR+MVCC能解决幻读吗？不能，即使是在RR级别下，MVCC虽然能解决大部分的幻读问题，但依然存在部分幻读问题无法解决； 在RR模式下，mysql 的innodb引擎读取数据有两种方式快照读（Snapshot Read）和当前读（Current Read）； 快照读：读取开启事务时的已经提交的数据，即使后面有修改，当前事务也只能读取这个快照版本之前的事务数据； 当前读：通过 SELECT ... FOR UPDATE或SELECT ... LOCK IN SHARE MODE方式执行的查询，会读取最新提交的数据，而不是开启事务之前版本的数据； TIP：快照读主要适用于需要读取一致性数据的场景，比如报表生成或分析，其中数据的一致性比绝对实时性更重要；当前读适用于需要读取最新数据的场景，比如实时交易系统或需要立即反应最新数据变化的业务逻辑； 解决的方案： 使用串行化（Serializable）隔离级别：官方推荐方案，但这种解决方案，并发性能比较低。 RR + 锁：使用 RR 隔离级别，通过 SELECT ... FOR UPDATE加锁，可以保证在查询过程中，不会有别的事务插入数据； 如何保证数据库和缓存双写一致？ 解决缓存和数据库一致问题的常见解决方案有以下 4 种： 先修改数据库，后更新缓存。 先更新缓存，后修改数据库。 先修改数据库，后删除缓存。 先删除缓存，后修改数据库。 前3种都存在第一步执行成功第二步执行失败的问题，所以一般都是使用第4种，先删除缓存在更新数据库的方案，最起码能保证数据的一致性问题；但是这种方案其实也有一些问题，会存在旧值覆盖缓存的问题（先删了缓存，另一个线程看没有缓存，查库更新缓存，导致缓存中是旧值，数据库是新值）；如果我们想要达到最大程度的解决双写一致性问题，最终的解决方案就是MQ+延迟双删策略； 引入MQ保证消息不回丢失； 通过先删除缓存，修改数据库； 延时一段时间再次删除缓存； Undo log（回滚日志） 和 redo log（重做日志）是由什么区别？什么时候落盘的? Undo log保证了事务的原子性；redo log保证事务的持久性； undo log在事务开始修改数据时就会生成undo log日志记录，主要记录的是修改前的数据；redo log则是事务开始修改数据时，主要记录的执行的sql; Redo log需要实时的flush到磁盘（Redo log的flush写入磁盘时机是灵活的，InnoDB会根据配置和系统状态决定何时将Redo log从内存flush到磁盘，通常是在事务提交前后、定期或当Redo log buffer达到一定比例时）；undo log不需要实时的落盘，因为undo log是事务的一部分，事务提交后仍需要保存一段时间，以便其他事务能够读取旧的行版本（MVCC）。","tags":["面试","mysql"],"categories":["mysql"]},{"title":"个人能力演变讨论","path":"/post/c3bc3481.html","content":"引言一般公司中都会有职级相关的等级，例如初级、中级、高级等等类似的岗位任职资格，但是生活中总有人卡在某一个等级，有的人却能顺风顺水，到底是因为什么呢？我们下面要讲的是个人能力演变的底层逻辑，通过借鉴阿里的职级来介绍相应的能力层级。 职级 能力特点 业务能力 思维能力 写作能力 变革能力 P4,P5….. 为什么人的能力千千万，我们却只用“业务能力”、“思维能力”、“协作能力”、“变革能力”这四种能力来做衡量维度？ P4级别： 职级 思维形象 能力特点 业务能力 思维能力 写作能力 变革能力 P4 点 初识事 4无1带 思维来源：从小养成的“听话”习惯； 心理分析：自我价值认知是“完成”，从“表扬”中获得满足感； 行事方式：追求快速完成 思维特点：让干啥干啥，不问为什么 管理者视角：能帮你干事，不能帮你想事。经常听不懂任务，需要过程辅导和监督； Tip: P4只关注事情本事，不关注事情的来源和事情的结果；4无1带是指无方法、无方向、无能力、无经验，需要人带； P5级别： 职级 思维形象 能力特点 业务能力 思维能力 写作能力 变革能力 P5 动点 事推人 独立交付 思辨能力 思维来源：之前新人期被教育过，明白了不是快就好 心理分析：干多了就腻了，关注怎么更省事轻松。做同样的事，要比小白强； 行事方式：会总结方法，甚至发明工具。除了速度，更看重质量； 思维特点：不想做无用功，所以开始关注正确理解任务，提高客户满意度； 管理者视角：只要说清楚要求，大多数时候能独立完成任务。但很少能超出预期。 Tip: P5心中有用户，能独立负责一摊子事，但还是属于被动的执行者；容易陷入研究“技术”的陷阱，去死扣所谓的专业； P6级别： 职级 思维形象 能力特点 业务能力 思维能力 写作能力 变革能力 P6 自运行点 人推事 主动担当、独挡一面 konw why 思维来源：通过大量重复执行，开始摸索任务的规律； 心理分析：领导动嘴，事全我干，凭什么？我想知道管理的秘密； 行事方式：会去理解做事的目的是什么，以此来指引行为，交付结果，体现价值； 思维特点：知道了为什么要做事，就可以自己做主了。所以开始观察和探索；（什么时刻，发生了什么问题，领导是怎么解决问题，是如何形成闭环） 管理者视角：主动性越来越强，有时都可以给自己提醒。有一点管理者的味道了； Tip: 知道为什么做，能主动发现问题，并解决问题。—– 这一阶段，人开始主导事。 P7级别： 职级 思维形象 能力特点 业务能力 思维能力 写作能力 变革能力 P7 线 策略做事 单线打通 有策略、有取舍 上下游联动 推动产品、服务、流程优化 思维来源：我看懂了事的为什么，才发现原来每个事里都有很多人在运动； 心理分析：原来事能不能成，关键不在事上，而在人上； 行事方式：从做人的角度去考虑做事，在做事之前，就能想到人的问题怎么处理； 思维特点：所以开始策略思考问题，想成事，哪些人人可用，哪些人别碰； 管理者视角：已经能从事里面抬头来，看到事是人链接的工具，做事更有套路了； Tip: 能前后链条一起看，会讲策略地拿结果。—– 这一阶段，我在事中看到了人 总结： 职级 能力特点 业务能力 思维能力 写作能力 变革能力 P4 点 初识事 4无1带 P5 动点 事推人 独立交付 思辨能力 P6 自运行点 人推事 主动担当、独挡一面 konw why P7 线 策略做事 单线打通 有策略、有取舍 上下游联动","tags":["职业发展"]},{"title":"hexo搭建博客流程","path":"/post/4a17b156.html","content":"本地环境搭建 以hexo官方文档为准：hexo环境准备 创建一个github page项目 参考Stellar 说明文档：创建github page页面 &amp;&amp; 开启github page教程 Tip: 创建github page页面的项目一定要设置为public，如果设置为private会导致通过https://xxxx.github.io/这种github提供的域名无法访问对应的页面。 创建一个private的项目，用于存放 设置自定义域名 使用 Vercel 部署，vercel类似于github page，但远比github page强大，速度也快得多得多，而且将Github授权给vercel后，可以达到最优雅的发布体验，只需将代码轻轻一推，项目就自动更新部署了 域名配置 使用七牛云搭建图床 PicGo 图片压缩插件 tinypng","tags":["hexo"],"categories":["hexo"]}]